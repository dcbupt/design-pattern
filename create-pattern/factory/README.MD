> 遵循工厂模式的概念，在实际应用中衍生出了几种设计模式，分别是简单工厂、工厂包、抽象工厂

简单工厂
- 由工厂类负责按需创建同一类产品（实现了相同接口的对象实例）
- 缺点：增加新类型的产品时，需要修改工厂类的工厂方法
- 解决办法：抽象"工厂方法"得到抽象工厂，每个类型的产品都有自己独立的工厂实例，负责创建产品实例

抽象工厂
- 将创建产品实例的工厂方法抽象为接口，得到抽象工厂，由抽象工厂的实现类负责创建产品实例，每个类型的产品都有自己的抽象工厂实例
- 由工厂制造器负责按需创建特定的工厂实例

抽象工厂的应用场景：
- 工厂无法预期它必须创建的产品实例类型
- 希望由不同的工厂分别创建自己领域下的产品实例

工厂包
- 使用Builder构建（不可更改的）产品实例的方式定义工厂
- Builder与工厂是分离的，由业务方使用Builder构建工厂的产品实例
- 实现方案使用JAVA8的函数式接口：Consumer、Supplier
	- Consumer是消费者，专注于处理Consumer的泛型入参
	- 使用Builder接口作为Consumer的泛型入参，业务方实现Consumer，调用Builder的add方法向工厂添加产品实例
	- 工厂提供Builder的实现类，获取业务方提供的产品实例并添加到工厂，简单的实现方式就是一个Map
	- Supplier是提供者，专注于提供产品
	- Builder的接口方法参数使用Supplier，业务方在调用Builder的add方法时，实现Supplier，自定义产品实例的创建逻辑

工厂包的应用场景：
- 工厂无法预期它必须创建的产品实例类型
- 业务方自定义Builder来灵活构建自适应工厂，而非依赖全局工厂
- 明确知道工厂需要产出的产品实例类型